# début du "core" version "23"
try:
    __core_already_done
except NameError:
    __core_already_done = False

if not __core_already_done:
    from memoire import mem
    from dictionnaire import create
    from piles import piles
    import uasyncio as asyncio

    TRACE = False

    def trace(msg):
        if TRACE:
            print(f"[CORE] {msg}")

    # ========== NIVEAU 0 : PRIMITIVES (opcodes < 100) ==========
    # Ces opcodes seront traduits en assembleur ESP32
    
    OP_EXIT     = 0   # Fin d'exécution
    OP_DUP      = 1   # Stack
    OP_DROP     = 2
    OP_SWAP     = 3
    OP_OVER     = 4
    OP_ROT      = 5
    OP_ADD      = 6   # Arithmetic
    OP_SUB      = 7
    OP_MUL      = 8
    OP_DIV      = 9
    OP_MOD      = 10
    OP_NEGATE   = 11
    OP_ABS      = 12
    OP_FETCH    = 13  # Memory: @
    OP_STORE    = 14  # Memory: !
    OP_CFETCH   = 15  # Memory: C@
    OP_CSTORE   = 16  # Memory: C!
    OP_DOT      = 17  # Output: .
    OP_CR       = 18
    OP_EMIT     = 19
    OP_KEY      = 20  # Input
    OP_LIT      = 21  # Literals
    OP_BRANCH   = 22  # Control flow
    OP_ZBRANCH  = 23  # 0BRANCH (IF)
    OP_COLON    = 24  # Compilation markers
    OP_SEMI     = 25
    OP_LBRACKET = 26  # [ ] mode
    OP_RBRACKET = 27
    OP_IMMEDIATE = 28
    OP_WORDS    = 29  # Debug
    OP_DOTSS    = 30  # .S
    OP_TESTS    = 31

    # Primitives (fonctions async)
    async def prim_exit():
        trace("OP_EXIT")
        pass

    async def prim_dup():
        trace("OP_DUP")
        x = await piles.pop()
        await piles.push(x)
        await piles.push(x)

    async def prim_drop():
        trace("OP_DROP")
        await piles.pop()

    async def prim_swap():
        trace("OP_SWAP")
        a = await piles.pop()
        b = await piles.pop()
        await piles.push(a)
        await piles.push(b)

    async def prim_over():
        trace("OP_OVER")
        a = await piles.pop()
        b = await piles.pop()
        await piles.push(b)
        await piles.push(a)
        await piles.push(b)

    async def prim_rot():
        trace("OP_ROT")
        a = await piles.pop()
        b = await piles.pop()
        c = await piles.pop()
        await piles.push(a)
        await piles.push(c)
        await piles.push(b)

    async def prim_add():
        trace("OP_ADD")
        b = await piles.pop()
        a = await piles.pop()
        result = a + b
        await piles.push(result)

    async def prim_sub():
        trace("OP_SUB")
        b = await piles.pop()
        a = await piles.pop()
        result = a - b
        await piles.push(result)

    async def prim_mul():
        trace("OP_MUL")
        b = await piles.pop()
        a = await piles.pop()
        result = a * b
        await piles.push(result)

    async def prim_div():
        trace("OP_DIV")
        b = await piles.pop()
        a = await piles.pop()
        if b == 0:
            raise ValueError("Division by zero")
        result = a // b
        await piles.push(result)

    async def prim_mod():
        trace("OP_MOD")
        b = await piles.pop()
        a = await piles.pop()
        if b == 0:
            raise ValueError("Division by zero")
        result = a % b
        await piles.push(result)

    async def prim_negate():
        trace("OP_NEGATE")
        x = await piles.pop()
        await piles.push(-x)

    async def prim_abs():
        trace("OP_ABS")
        x = await piles.pop()
        await piles.push(abs(x))

    async def prim_fetch():
        trace("OP_FETCH (@)")
        addr = await piles.pop()
        val = mem.wpeek(addr)
        await piles.push(val)

    async def prim_store():
        trace("OP_STORE (!)")
        addr = await piles.pop()
        val = await piles.pop()
        mem.wpoke(addr, val)

    async def prim_cfetch():
        trace("OP_CFETCH (C@)")
        addr = await piles.pop()
        val = mem.cpeek(addr)
        await piles.push(val)

    async def prim_cstore():
        trace("OP_CSTORE (C!)")
        addr = await piles.pop()
        val = await piles.pop()
        mem.cpoke(addr, val & 0xFF)

    async def prim_dot():
        trace("OP_DOT")
        val = await piles.pop()
        print(val, end=' ')

    async def prim_cr():
        trace("OP_CR")
        print()

    async def prim_emit():
        trace("OP_EMIT")
        code = await piles.pop()
        print(chr(code & 0xFF), end='')

    async def prim_key():
        trace("OP_KEY")
        # Simulation : lire un caractère
        try:
            ch = input()
            await piles.push(ord(ch[0]) if ch else 0)
        except:
            await piles.push(0)

    async def prim_lit():
        trace(f"OP_LIT (ip={mem.ip})")
        val = mem.wpeek(mem.ip)
        mem.ip += 4
        await piles.push(val)

    async def prim_branch():
        trace("OP_BRANCH")
        target = mem.wpeek(mem.ip)
        mem.ip = target

    async def prim_zbranch():
        trace("OP_ZBRANCH")
        target = mem.wpeek(mem.ip)
        mem.ip += 4
        cond = await piles.pop()
        if cond == 0:
            mem.ip = target

    async def prim_words():
        trace("OP_WORDS")
        print()
        addr = mem.latest
        count = 0
        while addr:
            link = mem.wpeek(addr)
            addr += 4
            fl = mem.cpeek(addr)
            length = fl & 0x7F
            immediate = bool(fl & 0x80)
            addr += 1
            name = ""
            for i in range(length):
                name += chr(mem.cpeek(addr + i))
            addr += length
            addr += (4 - addr % 4) % 4
            imm_marker = "!" if immediate else " "
            print(f"{name:15} {imm_marker}", end='  ')
            count += 1
            if count % 4 == 0:
                print()
            addr = link
        print()

    async def prim_dotss():
        trace("OP_DOTSS (.S)")
        print("[ ", end='')
        i = mem.sp
        while i < mem.SP0:
            val = mem.wpeek(i)
            print(val, end=' ')
            i += 4
        print("]")

    async def prim_tests():
        trace("OP_TESTS")
        try:
            import tests
            await tests.run_all_tests()
        except Exception as e:
            print(f"ERREUR TESTS: {e}")

    # Dispatch table : OP_* -> fonction async
    dispatch = {
        OP_EXIT:     prim_exit,
        OP_DUP:      prim_dup,
        OP_DROP:     prim_drop,
        OP_SWAP:     prim_swap,
        OP_OVER:     prim_over,
        OP_ROT:      prim_rot,
        OP_ADD:      prim_add,
        OP_SUB:      prim_sub,
        OP_MUL:      prim_mul,
        OP_DIV:      prim_div,
        OP_MOD:      prim_mod,
        OP_NEGATE:   prim_negate,
        OP_ABS:      prim_abs,
        OP_FETCH:    prim_fetch,
        OP_STORE:    prim_store,
        OP_CFETCH:   prim_cfetch,
        OP_CSTORE:   prim_cstore,
        OP_DOT:      prim_dot,
        OP_CR:       prim_cr,
        OP_EMIT:     prim_emit,
        OP_KEY:      prim_key,
        OP_LIT:      prim_lit,
        OP_BRANCH:   prim_branch,
        OP_ZBRANCH:  prim_zbranch,
        OP_WORDS:    prim_words,
        OP_DOTSS:    prim_dotss,
        OP_TESTS:    prim_tests,
    }

    # Réinitialiser et créer les primitives
    mem.reset_memory()

    create("EXIT",    OP_EXIT)
    create("DUP",     OP_DUP)
    create("DROP",    OP_DROP)
    create("SWAP",    OP_SWAP)
    create("OVER",    OP_OVER)
    create("ROT",     OP_ROT)
    create("+",       OP_ADD)
    create("-",       OP_SUB)
    create("*",       OP_MUL)
    create("/",       OP_DIV)
    create("MOD",     OP_MOD)
    create("NEGATE",  OP_NEGATE)
    create("ABS",     OP_ABS)
    create("@",       OP_FETCH)
    create("!",       OP_STORE)
    create("C@",      OP_CFETCH)
    create("C!",      OP_CSTORE)
    create(".",       OP_DOT)
    create("CR",      OP_CR)
    create("EMIT",    OP_EMIT)
    create("KEY",     OP_KEY)
    create(":",       OP_COLON)
    create(";",       OP_SEMI)
    create("[",       OP_LBRACKET, immediate=True)
    create("]",       OP_RBRACKET, immediate=True)
    create("IMMEDIATE", OP_IMMEDIATE, immediate=True)
    create("TESTS",   OP_TESTS)
    create("WORDS",   OP_WORDS)
    create(".S",      OP_DOTSS)
    create("LITERAL", OP_LIT, immediate=True)

    print(f"core.py v23 – NIVEAU 0 : {mem.here} bytes, {14} primitives")
    __core_already_done = True

version = ('core.py', 23)
# fin du "core" version "23"