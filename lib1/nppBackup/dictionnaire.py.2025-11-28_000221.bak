# début du "dictionnaire" version "21"
print("début de dictionnaire.py v21")
version = ('dictionnaire.py', 21)

from memoire import mem

TRACE_DICT = False  # Activer pour debug

def trace(msg):
    if TRACE_DICT:
        print(f"[DICT] {msg}")

def align_here():
    pad = mem.here % 4
    if pad:
        mem.here += 4 - pad

def create(name, code_addr, immediate=False):
    """Créer une primitive (opcode < 100)"""
    align_here()
    header_start = mem.here
    trace(f"create('{name}', code_addr={code_addr})")
    trace(f"  header_start={header_start}, here={mem.here}")
    
    # Link vers le header précédent
    mem.wpoke(mem.here, mem.latest)
    mem.here += 4
    trace(f"  link written at {header_start}, here={mem.here}")
    
    # Flags + longueur
    flags = len(name) | (0x80 if immediate else 0)
    mem.cpoke(mem.here, flags)
    mem.here += 1
    trace(f"  flags={flags} written at {header_start+4}, here={mem.here}")
    
    # Nom
    for c in name.upper():
        mem.cpoke(mem.here, ord(c))
        mem.here += 1
    trace(f"  name '{name}' written, here={mem.here}")
    
    # Aligner
    align_here()
    trace(f"  after align: here={mem.here}")
    
    # Code address
    code_addr_pos = mem.here
    mem.wpoke(mem.here, code_addr)
    mem.here += 4
    trace(f"  code_addr={code_addr} written at {code_addr_pos}, here={mem.here}")
    
    # Mettre à jour latest
    mem.latest = header_start
    trace(f"  latest={mem.latest}\n")
    print(f"{name},", end="")

def create_colon_word(name, code_start):
    """Créer un mot défini par l'utilisateur"""
    align_here()
    header_start = mem.here
    trace(f"create_colon_word('{name}', code_start={code_start})")
    trace(f"  header_start={header_start}, here={mem.here}")
    
    # Link
    mem.wpoke(mem.here, mem.latest)
    mem.here += 4
    
    # Flags (juste longueur, pas immediate)
    mem.cpoke(mem.here, len(name))
    mem.here += 1
    
    # Nom
    for c in name.upper():
        mem.cpoke(mem.here, ord(c))
        mem.here += 1
    
    # Aligner
    align_here()
    
    # Stocker code_start + 1000
    code_val = code_start + 1000
    code_addr_pos = mem.here
    mem.wpoke(mem.here, code_val)
    mem.here += 4
    trace(f"  code_val={code_val} written at {code_addr_pos}")
    
    # Mettre à jour latest
    mem.latest = header_start
    trace(f"  latest={mem.latest}\n")

def find(word):
    """Chercher un mot"""
    w = word.upper()
    trace(f"find('{w}')")
    addr = mem.latest
    
    while addr:
        trace(f"  checking at {addr}")
        
        # Link
        link = mem.wpeek(addr)
        addr += 4
        trace(f"    link={link}, addr now {addr}")
        
        # Flags
        fl = mem.cpeek(addr)
        length = fl & 0x7F
        immediate = bool(fl & 0x80)
        trace(f"    flags={fl} (len={length}, imm={immediate})")
        addr += 1
        
        # Nom
        name = "".join(chr(mem.cpeek(addr + i)) for i in range(length))
        trace(f"    name='{name}'")
        addr += length
        
        # Aligner
        addr += (4 - addr % 4) % 4
        trace(f"    after align: addr={addr}")
        
        # Code address
        code_val = mem.wpeek(addr)
        trace(f"    code_val={code_val}")
        
        if name == w:
            trace(f"  FOUND: returning ({code_val}, {immediate})\n")
            return code_val, immediate
        
        addr = link
    
    trace(f"  NOT FOUND\n")
    return None, False

def see(word):
    """Afficher le bytecode d'un mot"""
    opcode, _ = find(word)
    if opcode is None:
        print(f"? {word}")
        return
    
    if opcode >= 1000:
        addr = opcode - 1000
    else:
        print(f"{word} est une primitive (opcode {opcode})")
        return
    
    print(f"\n: {word.upper()}")
    while True:
        op = mem.wpeek(addr)
        addr += 4
        if op == 0:
            print(";")
            break
        if op == 21:
            val = mem.wpeek(addr)
            addr += 4
            print(val, end=' ')
        elif op == 22:
            target = mem.wpeek(addr)
            addr += 4
            print(f"BRANCH {target:#x}", end=' ')
        elif op == 23:
            target = mem.wpeek(addr)
            addr += 4
            print(f"0BRANCH {target:#x}", end=' ')
        else:
            name_rev = ""
            a = mem.latest
            while a:
                link = mem.wpeek(a)
                a += 4
                fl = mem.cpeek(a)
                length = fl & 0x7F
                a += 1
                name = "".join(chr(mem.cpeek(a + i)) for i in range(length))
                a += length + (4 - a % 4) % 4
                stored_val = mem.wpeek(a)
                if stored_val >= 1000:
                    stored_val -= 1000
                if stored_val == op:
                    name_rev = name
                    break
                a = link
            print(name_rev or f"[{op}]", end=' ')
    print()

def forget(word):
    """Oublier un mot"""
    opcode, _ = find(word)
    if opcode is None:
        print(f"? {word}")
        return
    addr = mem.latest
    prev = 0
    while addr:
        link = mem.wpeek(addr)
        if mem.wpeek(addr + 4 + 1 + (mem.cpeek(addr + 4) & 0x7F) + (4 - (addr + 5 + (mem.cpeek(addr + 4) & 0x7F)) % 4) % 4) == opcode:
            if prev == 0:
                mem.latest = link
            else:
                mem.wpoke(prev, link)
            print(f"{word} oublié")
            return
        prev = addr
        addr = link

print("fin de dictionnaire.py v21")
# fin du "dictionnaire" version "21"