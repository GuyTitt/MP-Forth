# début du "dictionnaire" version "23"
version = ('dictionnaire.py', 23)
print("début de dictionnaire.py v23")

from memoire import mem

TRACE_DICT = False  # Activer pour debug

def trace(msg):
    if TRACE_DICT:
        print(f"[DICT] {msg}")

def align_here():
    pad = mem.here % 4
    if pad:
        mem.here += 4 - pad

def create(name, code_addr, immediate=False):
    """Créer une primitive (opcode < 100)"""
    align_here()
    header_start = mem.here
    trace(f"create('{name}', code_addr={code_addr})")
    trace(f"  header_start={header_start}, here={mem.here}")
    
    # Link vers le header précédent
    mem.wpoke(mem.here, mem.latest)
    mem.here += 4
    trace(f"  link written at {header_start}, here={mem.here}")
    
    # Flags + longueur
    flags = len(name) | (0x80 if immediate else 0)
    mem.cpoke(mem.here, flags)
    mem.here += 1
    trace(f"  flags={flags} written at {header_start+4}, here={mem.here}")
    
    # Nom
    for c in name.upper():
        mem.cpoke(mem.here, ord(c))
        mem.here += 1
    trace(f"  name '{name}' written, here={mem.here}")
    
    # Aligner
    align_here()
    trace(f"  after align: here={mem.here}")
    
    # Code address
    code_addr_pos = mem.here
    mem.wpoke(mem.here, code_addr)
    mem.here += 4
    trace(f"  code_addr={code_addr} written at {code_addr_pos}, here={mem.here}")
    
    # Mettre à jour latest
    mem.latest = header_start
    trace(f"  latest={mem.latest}\n")
#    print(f"{name},", end="")

def create_colon_word(name, code_start):
    """Créer un mot défini par l'utilisateur"""
    align_here()
    header_start = mem.here
    trace(f"create_colon_word('{name}', code_start={code_start})")
    trace(f"  header_start={header_start}, here={mem.here}")
    
    # Link
    mem.wpoke(mem.here, mem.latest)
    mem.here += 4
    
    # Flags (juste longueur, pas immediate)
    mem.cpoke(mem.here, len(name))
    mem.here += 1
    
    # Nom
    for c in name.upper():
        mem.cpoke(mem.here, ord(c))
        mem.here += 1
    
    # Aligner
    align_here()
    
    # Stocker code_start + 1000
    code_val = code_start + 1000
    code_addr_pos = mem.here
    mem.wpoke(mem.here, code_val)
    mem.here += 4
    trace(f"  code_val={code_val} written at {code_addr_pos}")
    
    # Mettre à jour latest
    mem.latest = header_start
    trace(f"  latest={mem.latest}\n")

def find(word):
    """Chercher un mot"""
    w = word.upper()
    trace(f"find('{w}')")
    addr = mem.latest
    
    while addr:
        trace(f"  checking at {addr}")
        
        # Link
        link = mem.wpeek(addr)
        addr += 4
        trace(f"    link={link}, addr now {addr}")
        
        # Flags
        fl = mem.cpeek(addr)
        length = fl & 0x7F
        immediate = bool(fl & 0x80)
        trace(f"    flags={fl} (len={length}, imm={immediate})")
        addr += 1
        
        # Nom
        name = "".join(chr(mem.cpeek(addr + i)) for i in range(length))
        trace(f"    name='{name}'")
        addr += length
        
        # Aligner
        addr += (4 - addr % 4) % 4
        trace(f"    after align: addr={addr}")
        
        # Code address
        code_val = mem.wpeek(addr)
        trace(f"    code_val={code_val}")
        
        if name == w:
            trace(f"  FOUND: returning ({code_val}, {immediate})\n")
            return code_val, immediate
        
        addr = link
    
    trace(f"  NOT FOUND\n")
    return None, False

def see(word):
    """Afficher le bytecode d'un mot"""
    opcode, _ = find(word)
    if opcode is None:
        print(f"? {word}")
        return
    
    if opcode >= 1000:
        addr = opcode - 1000
    else:
        print(f"{word} est une primitive (opcode {opcode})")
        return
    
    print(f"\n: {word.upper()}")
    while True:
        op = mem.wpeek(addr)
        addr += 4
        if op == 0:
            print(";")
            break
        if op == 21:
            val = mem.wpeek(addr)
            addr += 4
            print(val, end=' ')
        elif op == 22:
            target = mem.wpeek(addr)
            addr += 4
            print(f"BRANCH {target:#x}", end=' ')
        elif op == 23:
            target = mem.wpeek(addr)
            addr += 4
            print(f"0BRANCH {target:#x}", end=' ')
        else:
            name_rev = ""
            a = mem.latest
            while a:
                link = mem.wpeek(a)
                a += 4
                fl = mem.cpeek(a)
                length = fl & 0x7F
                a += 1
                name = "".join(chr(mem.cpeek(a + i)) for i in range(length))
                a += length + (4 - a % 4) % 4
                stored_val = mem.wpeek(a)
                if stored_val >= 1000:
                    stored_val -= 1000
                if stored_val == op:
                    name_rev = name
                    break
                a = link
            print(name_rev or f"[{op}]", end=' ')
    print()

def forget(word):
    """Oublier un mot"""
    opcode, _ = find(word)
    if opcode is None:
        print(f"? {word}")
        return
    addr = mem.latest
    prev = 0
    while addr:
        link = mem.wpeek(addr)
        if mem.wpeek(addr + 4 + 1 + (mem.cpeek(addr + 4) & 0x7F) + (4 - (addr + 5 + (mem.cpeek(addr + 4) & 0x7F)) % 4) % 4) == opcode:
            if prev == 0:
                mem.latest = link
            else:
                mem.wpoke(prev, link)
            print(f"{word} oublié")
            return
        prev = addr
        addr = link
async def see_word(name):
    """Affiche le contenu d'un mot pour SEE – avec debug détaillé"""
    print(f"[DEBUG SEE] Recherche du mot : {name}")
    opcode, immediate = find(name.upper())
    if opcode is None:
        print(f"? {name} introuvable dans le dictionnaire")
        return

    print(f"[DEBUG SEE] trouvé → opcode={opcode} immediate={immediate}")

    if opcode < 1000:
        print(f"{name} est une primitive (opcode {opcode})")
        return

    print(f"{name}: ", end="")
    ip = opcode  # l'adresse du corps du mot
    print(f"[DEBUG SEE] corps commence à 0x{ip:08X}")

    count = 0
    while True:
        count += 1
        opc = mem.wpeek(ip)
        print(f"[DEBUG SEE] ip=0x{ip:08X} → opcode {opc}", end="")
        ip += 4

        if opc == 0:
            print(" → EXIT")
            break
        if opc == 21:  # LIT
            val = mem.wpeek(ip)
            ip += 4
            print(f" → LIT {val}")
            print(val, end=" ")
            continue

        # Recherche du nom correspondant à l'opcode
        found = False
        addr = mem.latest
        while addr:
            link = mem.wpeek(addr)
            addr += 4
            fl = mem.cpeek(addr)
            length = fl & 0x7F
            imm_flag = bool(fl & 0x80)
            addr += 1
            wname = ""
            for i in range(length):
                wname += chr(mem.cpeek(addr + i))
            # adresse du code field
            code_addr = addr + length + (4 - (length + 1) % 4) % 4
            code = mem.wpeek(code_addr)
            if code == opc:
                print(f" → {wname}{'!' if imm_flag else ''}")
                print(wname, end=" ")
                found = True
                break
            addr = link

        if not found:
            print(f" → [opcode inconnu {opc}]")
            print(f"[{opc}]", end=" ")

    print(f"[DEBUG SEE] fin du mot après {count} instructions")
print("fin de dictionnaire.py v23")
# fin du "dictionnaire" version "23"