# début du "core_system" version "35"
version = ('core_system.py', 35)

try:
    __core_sys_done
except NameError:
    __core_sys_done = False

if not __core_sys_done:
    from memoire import mem
    from dictionnaire import create
    from piles import piles
    import uasyncio as asyncio

    from core_primitives import (
        dispatch, OP_EXIT, OP_LIT, OP_ZBRANCH, OP_BRANCH,
        MARK_THEN, MARK_BEGIN, MARK_DO, MARK_LOOP,
        OP_WORDS, OP_DOTSS, OP_DEPTH, OP_TESTS, OP_FORGET, OP_SEE,
        OP_DEBUG, OP_HEX, OP_DECIMAL, OP_MIN, OP_MAX
    )

    OP_RECURSE   = 200
    OP_ONE_MINUS = 201

    async def prim_recurse():
        if mem.state == 0:
            print("? RECURSE hors définition")
            return
        code_addr = mem.wpeek(mem.latest + 4)
        mem.wpoke(mem.here, code_addr)
        mem.here += 4

    async def prim_one_minus():
        x = await piles.pop()
        await piles.push(x - 1)

    async def prim_words():
        addr = mem.latest
        count = 0
        while addr:
            link = mem.wpeek(addr)
            addr += 4
            fl = mem.cpeek(addr)
            length = fl & 0x7F
            immediate = "!" if fl & 0x80 else " "
            addr += 1
            name = "".join(chr(mem.cpeek(addr + i)) for i in range(length))
            addr += length + (4 - length % 4) % 4
            print(f"{name:15}{immediate}", end="")
            count += 1
            if count % 6 == 0: print()
            addr = link
        if count % 6 != 0: print()

    async def prim_dotss():
        depth = (mem.SP0 - mem.sp) // 4
        print(f"<{depth}:", end=" ")
        i = mem.sp
        while i < mem.SP0:
            print(mem.wpeek(i), end=" ")
            i += 4
        print(">", end="")
        if depth == 0:
            print(" <empty>", end="")
        print()

    async def prim_depth():
        await piles.push((mem.SP0 - mem.sp) // 4)

    async def prim_see():
        word = ""
        sp = mem.sp
        while sp < mem.SP0:
            c = mem.wpeek(sp) & 0xFF
            if c == 0: break
            word += chr(c)
            sp += 4
        if not word:
            print("? mot vide")
            return
        from dictionnaire import see_word
        await see_word(word.strip())

    dispatch.update({
        OP_RECURSE:   prim_recurse,
        OP_ONE_MINUS: prim_one_minus,
        OP_WORDS:     prim_words,
        OP_DOTSS:     prim_dotss,
        OP_DEPTH:     prim_depth,
        OP_SEE:       prim_see,
    })

    def c(name, opcode, immediate=False):
        create(name, opcode, immediate=immediate)
        print(name, end=" ")

    print("\nCréation dictionnaire système:")
    c("EXIT", OP_EXIT, immediate=True)
    c("DUP", 1); c("DROP", 2); c("SWAP", 3); c("OVER", 4); c("ROT", 5)
    c("2DUP", 34); c("2DROP", 35); c("NIP", 36); c("TUCK", 37)
    c("+", 6); c("-", 7); c("*", 8); c("/", 9); c("MOD", 10)
    c("NEGATE", 11); c("ABS", 12)
    c("<", 111); c(">", 112); c("=", 113); c("0<", 114); c("0=", 115); c("U<", 119)
    c("@", 13); c("!", 14); c("C@", 15); c("C!", 16); c("+@", 38); c("+!", 39)
    c(".", 17); c("CR", 18); c("EMIT", 19); c("SPACE", 40); c("SPACES", 41)
    c("AND", 42); c("OR", 43); c("XOR", 44); c("NOT", 45)
    c("IF", OP_ZBRANCH, immediate=True)
    c("ELSE", OP_BRANCH, immediate=True)
    c("THEN", MARK_THEN, immediate=True)
    c("BEGIN", MARK_BEGIN, immediate=True)
    c("UNTIL", OP_ZBRANCH, immediate=True)
    c("AGAIN", OP_BRANCH, immediate=True)
    c("DO", MARK_DO, immediate=True)
    c("LOOP", MARK_LOOP, immediate=True)
    c("+LOOP", MARK_LOOP, immediate=True)
    c("I", 109); c("J", 110)
    c("WORDS", OP_WORDS)
    c(".S", OP_DOTSS)
    c("DEPTH", OP_DEPTH)
    c("SEE", OP_SEE)
    c("DEBUG", OP_DEBUG)
    c("HEX", OP_HEX)
    c("DECIMAL", OP_DECIMAL)
    c("LITERAL", OP_LIT, immediate=True)
    c("RECURSE", OP_RECURSE, immediate=True)
    c("1-", OP_ONE_MINUS)
    c("MIN", OP_MIN)
    c("MAX", OP_MAX)
    print("\ncore_system.py v35 chargé – SEE .S WORDS corrigés")

    __core_sys_done = True

# fin du "core_system" version "35"